\documentclass[a4paper]{article}
\usepackage{a4wide,graphicx,color}
\usepackage[authoryear,round,longnamesfirst]{natbib}
\usepackage{hyperref}
\usepackage{underscore}

\definecolor{Red}{rgb}{0.7,0,0}
\definecolor{Blue}{rgb}{0,0,0.8}


\begin{document}

\SweaveOpts{engine=R,eps=FALSE}
%\VignetteIndexEntry{Qualitative Comparative Analysis using QCA3}
%\VignetteDepends{QCA3,lpSolve}
%\VignetteKeywords{qualitative comparative analysis}
%\VignettePackage{QCA3}

<<preliminaries,echo=FALSE,results=hide>>=
library(QCA3)
options(SweaveHooks=list(twofig=function() {par(mfrow=c(1,2))},
                         twofig2=function() {par(mfrow=c(2,1))},
                         onefig=function() {par(mfrow=c(1,1))}))
@

\title{Qualitative Comparative Analysis with QCA3}
\author{Ronggui Huang}
\date{\today}
\maketitle

\section{Introduction}
QCA3 can do various types of qualitative comparative analysis, namely
crisp set QCA, fuzzy set QCA and multi-value QCA.
It also allows inclusion of simplifying assumptions and can produce
intermediate solutions.

All examples in \cite{RihouxRagin2009} can be fully reproduced by QCA3 package.

\section{Crisp set QCA}

Before you conduct csQCA with QCA3, you need to import your dataset into R. If
your data is in Excel format, I would recommend you to export the data
to a csv file and import the csv file into R by read.csv function. In
this article, all datasets are shipped with the QCA3 package, and I
will skip the steps of data import.

In crisp set QCA (csQCA), all variables are binary (0 or
1). The dataset in this example is Lipset_cs. The first step is to
construct a truth table and examine it. You can use the function of
cs_truthTable to do it.

<<>>=
(cst <- cs_truthTable(Lipset_cs,outcome="SURVIVAL",
                      condition=c("GNPCAP", "URBANIZA", "LITERACY", "INDLAB", "GOVSTAB"),
                      cases="CASEID"))
@

The above command constructs a truth table and assigns it to an object
called cst, which can be used in the following analyses. You can
choose any legitimate object name to store the produced truth table as long as it is a
legitimate name in R.

In this command, Lipset_cs is the data frame which contains all the variables. The
argument of outcome specificifies the explained variable, say "SURVIVAL"
in this example (note you need to enclose SURVIVAL with
quotation mark). The argument of condition specificies the explanatory
variables. It is a string vector, each element of which is a
condition. At least two conditions are needed. In this example, five
conditions are provided. All variables, be outcome or condition, are
in the data frame of Lipset_cs. For more details, you can refer to the
help page of cs_truthTable.

The truth table is constructed by cs_truthTable automatically.
However, you can also manually override the outcome by function of
setOUT, but I will not go through the details here.

At this moment, you  need to to handle contradictory
configurations if any. Once you have a truth table without
contradictory configuration or you have come up a strategy to handle
them, you can move to the next step, minimization of the truth table without including remainders.

All you need to to is to pass the truth table, cst, produced previously, to the reduce function.
<<>>=
reduce(cst)
@

The default explains positive outcome (in this case,
SURVIVAL=1). If you want to explain negative outcome, you need to set
the argument of explain to "negative". That is our third step.

<<>>=
reduce(cst, explain="negative")
@

By default, remainders are not used and no simplifying assumption is
made. The fourth step is to get the most parsimonious solution to
positive outcome by including remainders. All you need to
set the argument of remainders to "include".

<<>>=
reduce(cst, remainders="include")
@

Similarly, you can explain negative outcome by including
remainders. Now, you need to specify both arguments of explain and remainders.

<<>>=
reduce(cst, explain="negative", remainders="include")
@

Now, you may wonder what remainders have been included. It is always a
good idea to examine it. To do so, you need to assign the return of
reduce to an object first. Take the explanation of negative outcome
for example. Let assign it to an object called ansNeg. Then you can
pass ansNeg to the function of SA, which will return a list of
remainders used in the minimization, which are also called simplifying
assuptions. It shows that 18 remainders are included.

<<>>=
ansNeg <- reduce(cst, explain="negative", remainders="include")
SA(ansNeg)
@

\section{fsQCA}
Before jumping into fsQCA, it is always a good idea to explore the
bivariate relationship between outcome and condition variables. The
key measures are sufficiency scores and necessary scores. The suffnec
function takes a data frame as input and produces both sufficiency
scores and necessary scores matrices.

<<>>=
suffnec(Lipset_fs[,c("Survived.FZ","Developed.FZ","Urban.FZ",
                     "Literate.FZ","Industrial.FZ", "Stable.FZ")])
@

In the above command, Lipset_fs is the name of a data frame. Here I use
the "[" operator to extract a relevant subset, which is then passed to suffnec.

You can use a graph to depict the set-theoretic consistency and
coverage. The function fsplot provides a friendly interface. For
example, if you want to examine whether development and
urbanization are sufficient for regime survival, you can use the following command.

<<fig=TRUE>>=
fsplot(Survived.FZ~Developed.FZ+Urban.FZ,data=Lipset_fs)
@

The fsplot use a formula interface. The left hand side variable is the
outcome variable. The right hand side variables are explanatory
variables. When more than one variables are in the right hand side,
the fuzzy set operation of "and" is performed before calculating
consistency and coverage score.

\section{Session Information}
<<>>=
sessionInfo()
@
\bibliography{QCA3}
\bibliographystyle{abbrvnat}
\end{document}
